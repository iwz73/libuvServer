// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocol_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocol_2eproto;
class GuestInfo;
class GuestInfoDefaultTypeInternal;
extern GuestInfoDefaultTypeInternal _GuestInfo_default_instance_;
class GuestLoginReq;
class GuestLoginReqDefaultTypeInternal;
extern GuestLoginReqDefaultTypeInternal _GuestLoginReq_default_instance_;
class GuestLoginRes;
class GuestLoginResDefaultTypeInternal;
extern GuestLoginResDefaultTypeInternal _GuestLoginRes_default_instance_;
class GuestUpgradeReq;
class GuestUpgradeReqDefaultTypeInternal;
extern GuestUpgradeReqDefaultTypeInternal _GuestUpgradeReq_default_instance_;
class GuestUpgradeRes;
class GuestUpgradeResDefaultTypeInternal;
extern GuestUpgradeResDefaultTypeInternal _GuestUpgradeRes_default_instance_;
class LoginReq;
class LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class LoginRes;
class LoginResDefaultTypeInternal;
extern LoginResDefaultTypeInternal _LoginRes_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::GuestInfo* Arena::CreateMaybeMessage<::GuestInfo>(Arena*);
template<> ::GuestLoginReq* Arena::CreateMaybeMessage<::GuestLoginReq>(Arena*);
template<> ::GuestLoginRes* Arena::CreateMaybeMessage<::GuestLoginRes>(Arena*);
template<> ::GuestUpgradeReq* Arena::CreateMaybeMessage<::GuestUpgradeReq>(Arena*);
template<> ::GuestUpgradeRes* Arena::CreateMaybeMessage<::GuestUpgradeRes>(Arena*);
template<> ::LoginReq* Arena::CreateMaybeMessage<::LoginReq>(Arena*);
template<> ::LoginRes* Arena::CreateMaybeMessage<::LoginRes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ServerType : int {
  defaultServer = 0,
  Auth = 1,
  System = 2,
  Logic = 3
};
bool ServerType_IsValid(int value);
constexpr ServerType ServerType_MIN = defaultServer;
constexpr ServerType ServerType_MAX = Logic;
constexpr int ServerType_ARRAYSIZE = ServerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerType_descriptor();
template<typename T>
inline const std::string& ServerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerType_descriptor(), enum_t_value);
}
inline bool ServerType_Parse(
    const std::string& name, ServerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerType>(
    ServerType_descriptor(), name, value);
}
enum CommandType : int {
  defaultCommand = 0,
  eGuestLoginReq = 1,
  eGuestLoginRes = 2,
  eLoginReq = 3,
  eLoginRes = 4,
  eGuestUpgradeReq = 5,
  eGuestUpgradeRes = 6
};
bool CommandType_IsValid(int value);
constexpr CommandType CommandType_MIN = defaultCommand;
constexpr CommandType CommandType_MAX = eGuestUpgradeRes;
constexpr int CommandType_ARRAYSIZE = CommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandType_descriptor();
template<typename T>
inline const std::string& CommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CommandType_descriptor(), enum_t_value);
}
inline bool CommandType_Parse(
    const std::string& name, CommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CommandType>(
    CommandType_descriptor(), name, value);
}
enum GameError : int {
  ok = 1,
  eSystemError = -1,
  eSqlDisconnect = -2,
  eLoginFreeze = -3,
  eLoginGuest = -4,
  eReLogin = -5,
  eUserLoseConn = -6,
  eGuestUserNameExist = -7
};
bool GameError_IsValid(int value);
constexpr GameError GameError_MIN = eGuestUserNameExist;
constexpr GameError GameError_MAX = ok;
constexpr int GameError_ARRAYSIZE = GameError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameError_descriptor();
template<typename T>
inline const std::string& GameError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameError_descriptor(), enum_t_value);
}
inline bool GameError_Parse(
    const std::string& name, GameError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameError>(
    GameError_descriptor(), name, value);
}
// ===================================================================

class GuestInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuestInfo) */ {
 public:
  GuestInfo();
  virtual ~GuestInfo();

  GuestInfo(const GuestInfo& from);
  GuestInfo(GuestInfo&& from) noexcept
    : GuestInfo() {
    *this = ::std::move(from);
  }

  inline GuestInfo& operator=(const GuestInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuestInfo& operator=(GuestInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GuestInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuestInfo* internal_default_instance() {
    return reinterpret_cast<const GuestInfo*>(
               &_GuestInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GuestInfo& a, GuestInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GuestInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuestInfo* New() const final {
    return CreateMaybeMessage<GuestInfo>(nullptr);
  }

  GuestInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuestInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuestInfo& from);
  void MergeFrom(const GuestInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuestInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuestInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNickFieldNumber = 1,
    kFaceImageFieldNumber = 2,
    kVipFieldNumber = 3,
    kStatusFieldNumber = 4,
    kGuestIdFieldNumber = 5,
  };
  // required string nick = 1;
  bool has_nick() const;
  private:
  bool _internal_has_nick() const;
  public:
  void clear_nick();
  const std::string& nick() const;
  void set_nick(const std::string& value);
  void set_nick(std::string&& value);
  void set_nick(const char* value);
  void set_nick(const char* value, size_t size);
  std::string* mutable_nick();
  std::string* release_nick();
  void set_allocated_nick(std::string* nick);
  private:
  const std::string& _internal_nick() const;
  void _internal_set_nick(const std::string& value);
  std::string* _internal_mutable_nick();
  public:

  // required int32 faceImage = 2;
  bool has_faceimage() const;
  private:
  bool _internal_has_faceimage() const;
  public:
  void clear_faceimage();
  ::PROTOBUF_NAMESPACE_ID::int32 faceimage() const;
  void set_faceimage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_faceimage() const;
  void _internal_set_faceimage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 vip = 3;
  bool has_vip() const;
  private:
  bool _internal_has_vip() const;
  public:
  void clear_vip();
  ::PROTOBUF_NAMESPACE_ID::int32 vip() const;
  void set_vip(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_vip() const;
  void _internal_set_vip(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required int32 guestId = 5;
  bool has_guestid() const;
  private:
  bool _internal_has_guestid() const;
  public:
  void clear_guestid();
  ::PROTOBUF_NAMESPACE_ID::int32 guestid() const;
  void set_guestid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_guestid() const;
  void _internal_set_guestid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GuestInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nick_;
  ::PROTOBUF_NAMESPACE_ID::int32 faceimage_;
  ::PROTOBUF_NAMESPACE_ID::int32 vip_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  ::PROTOBUF_NAMESPACE_ID::int32 guestid_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class GuestLoginReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuestLoginReq) */ {
 public:
  GuestLoginReq();
  virtual ~GuestLoginReq();

  GuestLoginReq(const GuestLoginReq& from);
  GuestLoginReq(GuestLoginReq&& from) noexcept
    : GuestLoginReq() {
    *this = ::std::move(from);
  }

  inline GuestLoginReq& operator=(const GuestLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuestLoginReq& operator=(GuestLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GuestLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuestLoginReq* internal_default_instance() {
    return reinterpret_cast<const GuestLoginReq*>(
               &_GuestLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GuestLoginReq& a, GuestLoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GuestLoginReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuestLoginReq* New() const final {
    return CreateMaybeMessage<GuestLoginReq>(nullptr);
  }

  GuestLoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuestLoginReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuestLoginReq& from);
  void MergeFrom(const GuestLoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuestLoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuestLoginReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRandKeyFieldNumber = 1,
  };
  // required string RandKey = 1;
  bool has_randkey() const;
  private:
  bool _internal_has_randkey() const;
  public:
  void clear_randkey();
  const std::string& randkey() const;
  void set_randkey(const std::string& value);
  void set_randkey(std::string&& value);
  void set_randkey(const char* value);
  void set_randkey(const char* value, size_t size);
  std::string* mutable_randkey();
  std::string* release_randkey();
  void set_allocated_randkey(std::string* randkey);
  private:
  const std::string& _internal_randkey() const;
  void _internal_set_randkey(const std::string& value);
  std::string* _internal_mutable_randkey();
  public:

  // @@protoc_insertion_point(class_scope:GuestLoginReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr randkey_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class GuestLoginRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuestLoginRes) */ {
 public:
  GuestLoginRes();
  virtual ~GuestLoginRes();

  GuestLoginRes(const GuestLoginRes& from);
  GuestLoginRes(GuestLoginRes&& from) noexcept
    : GuestLoginRes() {
    *this = ::std::move(from);
  }

  inline GuestLoginRes& operator=(const GuestLoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuestLoginRes& operator=(GuestLoginRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GuestLoginRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuestLoginRes* internal_default_instance() {
    return reinterpret_cast<const GuestLoginRes*>(
               &_GuestLoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GuestLoginRes& a, GuestLoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GuestLoginRes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuestLoginRes* New() const final {
    return CreateMaybeMessage<GuestLoginRes>(nullptr);
  }

  GuestLoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuestLoginRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuestLoginRes& from);
  void MergeFrom(const GuestLoginRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuestLoginRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuestLoginRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 2,
    kGuestErrorFieldNumber = 1,
  };
  // optional .GuestInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::GuestInfo& info() const;
  ::GuestInfo* release_info();
  ::GuestInfo* mutable_info();
  void set_allocated_info(::GuestInfo* info);
  private:
  const ::GuestInfo& _internal_info() const;
  ::GuestInfo* _internal_mutable_info();
  public:

  // required int32 guestError = 1;
  bool has_guesterror() const;
  private:
  bool _internal_has_guesterror() const;
  public:
  void clear_guesterror();
  ::PROTOBUF_NAMESPACE_ID::int32 guesterror() const;
  void set_guesterror(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_guesterror() const;
  void _internal_set_guesterror(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GuestLoginRes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::GuestInfo* info_;
  ::PROTOBUF_NAMESPACE_ID::int32 guesterror_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginReq) */ {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginReq* New() const final {
    return CreateMaybeMessage<LoginReq>(nullptr);
  }

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class LoginRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LoginRes) */ {
 public:
  LoginRes();
  virtual ~LoginRes();

  LoginRes(const LoginRes& from);
  LoginRes(LoginRes&& from) noexcept
    : LoginRes() {
    *this = ::std::move(from);
  }

  inline LoginRes& operator=(const LoginRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRes& operator=(LoginRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoginRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRes* internal_default_instance() {
    return reinterpret_cast<const LoginRes*>(
               &_LoginRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginRes& a, LoginRes& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginRes* New() const final {
    return CreateMaybeMessage<LoginRes>(nullptr);
  }

  LoginRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoginRes& from);
  void MergeFrom(const LoginRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LoginRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:LoginRes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class GuestUpgradeReq :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuestUpgradeReq) */ {
 public:
  GuestUpgradeReq();
  virtual ~GuestUpgradeReq();

  GuestUpgradeReq(const GuestUpgradeReq& from);
  GuestUpgradeReq(GuestUpgradeReq&& from) noexcept
    : GuestUpgradeReq() {
    *this = ::std::move(from);
  }

  inline GuestUpgradeReq& operator=(const GuestUpgradeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuestUpgradeReq& operator=(GuestUpgradeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GuestUpgradeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuestUpgradeReq* internal_default_instance() {
    return reinterpret_cast<const GuestUpgradeReq*>(
               &_GuestUpgradeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GuestUpgradeReq& a, GuestUpgradeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GuestUpgradeReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuestUpgradeReq* New() const final {
    return CreateMaybeMessage<GuestUpgradeReq>(nullptr);
  }

  GuestUpgradeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuestUpgradeReq>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuestUpgradeReq& from);
  void MergeFrom(const GuestUpgradeReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuestUpgradeReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuestUpgradeReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // required string username = 1;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // required string password = 2;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // @@protoc_insertion_point(class_scope:GuestUpgradeReq)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  friend struct ::TableStruct_protocol_2eproto;
};
// -------------------------------------------------------------------

class GuestUpgradeRes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GuestUpgradeRes) */ {
 public:
  GuestUpgradeRes();
  virtual ~GuestUpgradeRes();

  GuestUpgradeRes(const GuestUpgradeRes& from);
  GuestUpgradeRes(GuestUpgradeRes&& from) noexcept
    : GuestUpgradeRes() {
    *this = ::std::move(from);
  }

  inline GuestUpgradeRes& operator=(const GuestUpgradeRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuestUpgradeRes& operator=(GuestUpgradeRes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GuestUpgradeRes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GuestUpgradeRes* internal_default_instance() {
    return reinterpret_cast<const GuestUpgradeRes*>(
               &_GuestUpgradeRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GuestUpgradeRes& a, GuestUpgradeRes& b) {
    a.Swap(&b);
  }
  inline void Swap(GuestUpgradeRes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GuestUpgradeRes* New() const final {
    return CreateMaybeMessage<GuestUpgradeRes>(nullptr);
  }

  GuestUpgradeRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GuestUpgradeRes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GuestUpgradeRes& from);
  void MergeFrom(const GuestUpgradeRes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GuestUpgradeRes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GuestUpgradeRes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_protocol_2eproto);
    return ::descriptor_table_protocol_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
  };
  // required int32 status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::PROTOBUF_NAMESPACE_ID::int32 status() const;
  void set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_status() const;
  void _internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:GuestUpgradeRes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 status_;
  friend struct ::TableStruct_protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GuestInfo

// required string nick = 1;
inline bool GuestInfo::_internal_has_nick() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuestInfo::has_nick() const {
  return _internal_has_nick();
}
inline void GuestInfo::clear_nick() {
  nick_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GuestInfo::nick() const {
  // @@protoc_insertion_point(field_get:GuestInfo.nick)
  return _internal_nick();
}
inline void GuestInfo::set_nick(const std::string& value) {
  _internal_set_nick(value);
  // @@protoc_insertion_point(field_set:GuestInfo.nick)
}
inline std::string* GuestInfo::mutable_nick() {
  // @@protoc_insertion_point(field_mutable:GuestInfo.nick)
  return _internal_mutable_nick();
}
inline const std::string& GuestInfo::_internal_nick() const {
  return nick_.GetNoArena();
}
inline void GuestInfo::_internal_set_nick(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nick_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GuestInfo::set_nick(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  nick_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GuestInfo.nick)
}
inline void GuestInfo::set_nick(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  nick_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GuestInfo.nick)
}
inline void GuestInfo::set_nick(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  nick_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GuestInfo.nick)
}
inline std::string* GuestInfo::_internal_mutable_nick() {
  _has_bits_[0] |= 0x00000001u;
  return nick_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GuestInfo::release_nick() {
  // @@protoc_insertion_point(field_release:GuestInfo.nick)
  if (!has_nick()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return nick_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GuestInfo::set_allocated_nick(std::string* nick) {
  if (nick != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nick_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nick);
  // @@protoc_insertion_point(field_set_allocated:GuestInfo.nick)
}

// required int32 faceImage = 2;
inline bool GuestInfo::_internal_has_faceimage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GuestInfo::has_faceimage() const {
  return _internal_has_faceimage();
}
inline void GuestInfo::clear_faceimage() {
  faceimage_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::_internal_faceimage() const {
  return faceimage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::faceimage() const {
  // @@protoc_insertion_point(field_get:GuestInfo.faceImage)
  return _internal_faceimage();
}
inline void GuestInfo::_internal_set_faceimage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  faceimage_ = value;
}
inline void GuestInfo::set_faceimage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_faceimage(value);
  // @@protoc_insertion_point(field_set:GuestInfo.faceImage)
}

// required int32 vip = 3;
inline bool GuestInfo::_internal_has_vip() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GuestInfo::has_vip() const {
  return _internal_has_vip();
}
inline void GuestInfo::clear_vip() {
  vip_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::_internal_vip() const {
  return vip_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::vip() const {
  // @@protoc_insertion_point(field_get:GuestInfo.vip)
  return _internal_vip();
}
inline void GuestInfo::_internal_set_vip(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  vip_ = value;
}
inline void GuestInfo::set_vip(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_vip(value);
  // @@protoc_insertion_point(field_set:GuestInfo.vip)
}

// required int32 status = 4;
inline bool GuestInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GuestInfo::has_status() const {
  return _internal_has_status();
}
inline void GuestInfo::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::status() const {
  // @@protoc_insertion_point(field_get:GuestInfo.status)
  return _internal_status();
}
inline void GuestInfo::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  status_ = value;
}
inline void GuestInfo::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:GuestInfo.status)
}

// required int32 guestId = 5;
inline bool GuestInfo::_internal_has_guestid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GuestInfo::has_guestid() const {
  return _internal_has_guestid();
}
inline void GuestInfo::clear_guestid() {
  guestid_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::_internal_guestid() const {
  return guestid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestInfo::guestid() const {
  // @@protoc_insertion_point(field_get:GuestInfo.guestId)
  return _internal_guestid();
}
inline void GuestInfo::_internal_set_guestid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  guestid_ = value;
}
inline void GuestInfo::set_guestid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_guestid(value);
  // @@protoc_insertion_point(field_set:GuestInfo.guestId)
}

// -------------------------------------------------------------------

// GuestLoginReq

// required string RandKey = 1;
inline bool GuestLoginReq::_internal_has_randkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuestLoginReq::has_randkey() const {
  return _internal_has_randkey();
}
inline void GuestLoginReq::clear_randkey() {
  randkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GuestLoginReq::randkey() const {
  // @@protoc_insertion_point(field_get:GuestLoginReq.RandKey)
  return _internal_randkey();
}
inline void GuestLoginReq::set_randkey(const std::string& value) {
  _internal_set_randkey(value);
  // @@protoc_insertion_point(field_set:GuestLoginReq.RandKey)
}
inline std::string* GuestLoginReq::mutable_randkey() {
  // @@protoc_insertion_point(field_mutable:GuestLoginReq.RandKey)
  return _internal_mutable_randkey();
}
inline const std::string& GuestLoginReq::_internal_randkey() const {
  return randkey_.GetNoArena();
}
inline void GuestLoginReq::_internal_set_randkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  randkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GuestLoginReq::set_randkey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  randkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GuestLoginReq.RandKey)
}
inline void GuestLoginReq::set_randkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  randkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GuestLoginReq.RandKey)
}
inline void GuestLoginReq::set_randkey(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  randkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GuestLoginReq.RandKey)
}
inline std::string* GuestLoginReq::_internal_mutable_randkey() {
  _has_bits_[0] |= 0x00000001u;
  return randkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GuestLoginReq::release_randkey() {
  // @@protoc_insertion_point(field_release:GuestLoginReq.RandKey)
  if (!has_randkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return randkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GuestLoginReq::set_allocated_randkey(std::string* randkey) {
  if (randkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  randkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), randkey);
  // @@protoc_insertion_point(field_set_allocated:GuestLoginReq.RandKey)
}

// -------------------------------------------------------------------

// GuestLoginRes

// required int32 guestError = 1;
inline bool GuestLoginRes::_internal_has_guesterror() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GuestLoginRes::has_guesterror() const {
  return _internal_has_guesterror();
}
inline void GuestLoginRes::clear_guesterror() {
  guesterror_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestLoginRes::_internal_guesterror() const {
  return guesterror_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestLoginRes::guesterror() const {
  // @@protoc_insertion_point(field_get:GuestLoginRes.guestError)
  return _internal_guesterror();
}
inline void GuestLoginRes::_internal_set_guesterror(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  guesterror_ = value;
}
inline void GuestLoginRes::set_guesterror(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_guesterror(value);
  // @@protoc_insertion_point(field_set:GuestLoginRes.guestError)
}

// optional .GuestInfo info = 2;
inline bool GuestLoginRes::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool GuestLoginRes::has_info() const {
  return _internal_has_info();
}
inline void GuestLoginRes::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::GuestInfo& GuestLoginRes::_internal_info() const {
  const ::GuestInfo* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::GuestInfo*>(
      &::_GuestInfo_default_instance_);
}
inline const ::GuestInfo& GuestLoginRes::info() const {
  // @@protoc_insertion_point(field_get:GuestLoginRes.info)
  return _internal_info();
}
inline ::GuestInfo* GuestLoginRes::release_info() {
  // @@protoc_insertion_point(field_release:GuestLoginRes.info)
  _has_bits_[0] &= ~0x00000001u;
  ::GuestInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::GuestInfo* GuestLoginRes::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::GuestInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  return info_;
}
inline ::GuestInfo* GuestLoginRes::mutable_info() {
  // @@protoc_insertion_point(field_mutable:GuestLoginRes.info)
  return _internal_mutable_info();
}
inline void GuestLoginRes::set_allocated_info(::GuestInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:GuestLoginRes.info)
}

// -------------------------------------------------------------------

// LoginReq

// required string username = 1;
inline bool LoginReq::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginReq::has_username() const {
  return _internal_has_username();
}
inline void LoginReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginReq::username() const {
  // @@protoc_insertion_point(field_get:LoginReq.username)
  return _internal_username();
}
inline void LoginReq::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:LoginReq.username)
}
inline std::string* LoginReq::mutable_username() {
  // @@protoc_insertion_point(field_mutable:LoginReq.username)
  return _internal_mutable_username();
}
inline const std::string& LoginReq::_internal_username() const {
  return username_.GetNoArena();
}
inline void LoginReq::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoginReq::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginReq.username)
}
inline void LoginReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginReq.username)
}
inline void LoginReq::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginReq.username)
}
inline std::string* LoginReq::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginReq::release_username() {
  // @@protoc_insertion_point(field_release:LoginReq.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:LoginReq.username)
}

// required string password = 2;
inline bool LoginReq::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoginReq::has_password() const {
  return _internal_has_password();
}
inline void LoginReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginReq::password() const {
  // @@protoc_insertion_point(field_get:LoginReq.password)
  return _internal_password();
}
inline void LoginReq::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:LoginReq.password)
}
inline std::string* LoginReq::mutable_password() {
  // @@protoc_insertion_point(field_mutable:LoginReq.password)
  return _internal_mutable_password();
}
inline const std::string& LoginReq::_internal_password() const {
  return password_.GetNoArena();
}
inline void LoginReq::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoginReq::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LoginReq.password)
}
inline void LoginReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LoginReq.password)
}
inline void LoginReq::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LoginReq.password)
}
inline std::string* LoginReq::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginReq::release_password() {
  // @@protoc_insertion_point(field_release:LoginReq.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:LoginReq.password)
}

// -------------------------------------------------------------------

// LoginRes

// required int32 status = 1;
inline bool LoginRes::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoginRes::has_status() const {
  return _internal_has_status();
}
inline void LoginRes::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginRes::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginRes::status() const {
  // @@protoc_insertion_point(field_get:LoginRes.status)
  return _internal_status();
}
inline void LoginRes::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void LoginRes::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:LoginRes.status)
}

// -------------------------------------------------------------------

// GuestUpgradeReq

// required string username = 1;
inline bool GuestUpgradeReq::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuestUpgradeReq::has_username() const {
  return _internal_has_username();
}
inline void GuestUpgradeReq::clear_username() {
  username_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GuestUpgradeReq::username() const {
  // @@protoc_insertion_point(field_get:GuestUpgradeReq.username)
  return _internal_username();
}
inline void GuestUpgradeReq::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:GuestUpgradeReq.username)
}
inline std::string* GuestUpgradeReq::mutable_username() {
  // @@protoc_insertion_point(field_mutable:GuestUpgradeReq.username)
  return _internal_mutable_username();
}
inline const std::string& GuestUpgradeReq::_internal_username() const {
  return username_.GetNoArena();
}
inline void GuestUpgradeReq::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GuestUpgradeReq::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GuestUpgradeReq.username)
}
inline void GuestUpgradeReq::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GuestUpgradeReq.username)
}
inline void GuestUpgradeReq::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GuestUpgradeReq.username)
}
inline std::string* GuestUpgradeReq::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  return username_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GuestUpgradeReq::release_username() {
  // @@protoc_insertion_point(field_release:GuestUpgradeReq.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GuestUpgradeReq::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:GuestUpgradeReq.username)
}

// required string password = 2;
inline bool GuestUpgradeReq::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GuestUpgradeReq::has_password() const {
  return _internal_has_password();
}
inline void GuestUpgradeReq::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GuestUpgradeReq::password() const {
  // @@protoc_insertion_point(field_get:GuestUpgradeReq.password)
  return _internal_password();
}
inline void GuestUpgradeReq::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:GuestUpgradeReq.password)
}
inline std::string* GuestUpgradeReq::mutable_password() {
  // @@protoc_insertion_point(field_mutable:GuestUpgradeReq.password)
  return _internal_mutable_password();
}
inline const std::string& GuestUpgradeReq::_internal_password() const {
  return password_.GetNoArena();
}
inline void GuestUpgradeReq::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GuestUpgradeReq::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:GuestUpgradeReq.password)
}
inline void GuestUpgradeReq::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:GuestUpgradeReq.password)
}
inline void GuestUpgradeReq::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:GuestUpgradeReq.password)
}
inline std::string* GuestUpgradeReq::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GuestUpgradeReq::release_password() {
  // @@protoc_insertion_point(field_release:GuestUpgradeReq.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GuestUpgradeReq::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:GuestUpgradeReq.password)
}

// -------------------------------------------------------------------

// GuestUpgradeRes

// required int32 status = 1;
inline bool GuestUpgradeRes::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GuestUpgradeRes::has_status() const {
  return _internal_has_status();
}
inline void GuestUpgradeRes::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestUpgradeRes::_internal_status() const {
  return status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GuestUpgradeRes::status() const {
  // @@protoc_insertion_point(field_get:GuestUpgradeRes.status)
  return _internal_status();
}
inline void GuestUpgradeRes::_internal_set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  status_ = value;
}
inline void GuestUpgradeRes::set_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:GuestUpgradeRes.status)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ServerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ServerType>() {
  return ::ServerType_descriptor();
}
template <> struct is_proto_enum< ::CommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CommandType>() {
  return ::CommandType_descriptor();
}
template <> struct is_proto_enum< ::GameError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GameError>() {
  return ::GameError_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocol_2eproto
